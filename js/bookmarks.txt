// chrome.bookmarks.getTree(function(itemTree){
//   document.getElementById('bookmarks').innerHTML += itemTree[0].children[0].title;
// });

function makeIndent(indentLength) {
  return ".".repeat(indentLength);
}

function logItems(bookmarkItem, indent) {
  if (bookmarkItem.url) {
    console.log(makeIndent(indent) + bookmarkItem.url);
  } else {
    console.log(makeIndent(indent) + "Folder");
    indent++;
  }
  if (bookmarkItem.children) {
    for (child of bookmarkItem.children) {
      logItems(child, indent);
    }
  }
  indent--;
}

function logTree(bookmarkItems) {
  logItems(bookmarkItems[0], 0);
}

function onRejected(error) {
  console.log(`An error: ${error}`);
}

var gettingTree = chrome.bookmarks.getTree();
gettingTree.then(logTree, onRejected);


// function onFulfilled(bookmarks) {
//   console.log(bookmarks);
// }

// function onRejected(error) {
//   console.log(`An error: ${error}`);
// }

// var gettingBookmarks = chrome.bookmarks.get("0");
// gettingBookmarks.then(onFulfilled, onRejected);

// console.log(chrome.bookmarks)

// chrome.bookmarks.getRecent(20, function(items) {
//   items.forEach(function(item) {
//     document.getElementById('bookmarks').innerHTML += item.title + "<br>";
//   });
// });

// chrome.bookmarks.getTree(function(itemTree){
//   itemTree.forEach(function(item){
//       console.log(item);
//   });
// });

 function processNode(node) {
   // recursively process child nodes
   if(node.children) {
       node.children.forEach(function(child) { processNode(child); });
   }

   // print leaf nodes URLs to console
    if(node.url) { console.log(node.url); }
 }

